
#include "caster.h"
#include "constants.h"
#include <cmath>

void handleEvents(sf::RenderWindow& window) {
    sf::Event event;
    while (window.pollEvent(event)) {
        if (event.type == sf::Event::Closed)
            window.close();
    }
}

double calcFrameTime(sf::Clock& clock, double& oldTime) {
    sf::Time elapsed = clock.getElapsedTime();
    double now = elapsed.asMilliseconds();
    double frameTime = (now - oldTime) / 1000.0;
    oldTime = now;
    return frameTime;
}

void movement(const int worldMap[24][24],
              sf::Vector2<double>& pos,
              sf::Vector2<double>& dir,
              sf::Vector2<double>& plane,
              double moveSpeed,
              double rotSpeed) {

    if (sf::Keyboard::isKeyPressed(sf::Keyboard::W)) {
        if (worldMap[int(pos.x + dir.x * moveSpeed)][int(pos.y)] == 0)
            pos.x += dir.x * moveSpeed;
        if (worldMap[int(pos.x)][int(pos.y + dir.y * moveSpeed)] == 0)
            pos.y += dir.y * moveSpeed;
    }

    if (sf::Keyboard::isKeyPressed(sf::Keyboard::S)) {
        if (worldMap[int(pos.x - dir.x * moveSpeed)][int(pos.y)] == 0)
            pos.x -= dir.x * moveSpeed;
        if (worldMap[int(pos.x)][int(pos.y - dir.y * moveSpeed)] == 0)
            pos.y -= dir.y * moveSpeed;
    }

    if (sf::Keyboard::isKeyPressed(sf::Keyboard::D)) {
        double oldDirX = dir.x;
        dir.x = dir.x * cos(-rotSpeed) - dir.y * sin(-rotSpeed);
        dir.y = oldDirX * sin(-rotSpeed) + dir.y * cos(-rotSpeed);

        double oldPlaneX = plane.x;
        plane.x = plane.x * cos(-rotSpeed) - plane.y * sin(-rotSpeed);
        plane.y = oldPlaneX * sin(-rotSpeed) + plane.y * cos(-rotSpeed);
    }

    if (sf::Keyboard::isKeyPressed(sf::Keyboard::A)) {
        double oldDirX = dir.x;
        dir.x = dir.x * cos(rotSpeed) - dir.y * sin(rotSpeed);
        dir.y = oldDirX * sin(rotSpeed) + dir.y * cos(rotSpeed);

        double oldPlaneX = plane.x;
        plane.x = plane.x * cos(rotSpeed) - plane.y * sin(rotSpeed);
        plane.y = oldPlaneX * sin(rotSpeed) + plane.y * cos(rotSpeed);
    }
}
void castRays(sf::RenderWindow& window,
                       const int worldMap[24][24],
                       sf::Vector2<double>& playerPos,
                       sf::Vector2<double>& playerDir,
                       sf::Vector2<double>& playerPlane) {
    for (int x = 0; x < screenWidth; ++x) {
            double cameraX = 2.0 * x / double(screenWidth) - 1.0;
            sf::Vector2<double> rayDir(
                playerDir.x + playerPlane.x * cameraX,
                playerDir.y + playerPlane.y * cameraX
            );

            sf::Vector2<int> mapPos(int(playerPos.x), int(playerPos.y));

            sf::Vector2<double> sideDist;


            double bignum = 1e30;

            sf::Vector2<double> deltaDist(
                    (rayDir.x == 0.0) ? bignum : std::abs(1.0 / rayDir.x),
                    (rayDir.y == 0.0) ? bignum : std::abs(1.0 / rayDir.y)
                    );
            double perpWallDist = 0.0;


            sf::Vector2<int> step(0, 0);

            if(rayDir.x < 0) {
                step.x = -1;
                sideDist.x =(playerPos.x - mapPos.x) * deltaDist.x;
            } else {
                step.x = 1;
                sideDist.x =(mapPos.x + 1.0 - playerPos.x) * deltaDist.x;
            }

            if(rayDir.y < 0) {
                step.y = -1;
                sideDist.y =(playerPos.y - mapPos.y) * deltaDist.y;
            } else {
                step.y = 1;
                sideDist.y =(mapPos.y + 1.0 - playerPos.y) * deltaDist.y;
            }

            int hit = 0;
            int side = 0;
            while (hit == 0) {
                if (sideDist.x < sideDist.y) {
                    sideDist.x += deltaDist.x;
                    mapPos.x += step.x;
                    side = 0;
                } else {
                    sideDist.y += deltaDist.y;
                    mapPos.y += step.y;
                    side = 1;
                }

                if (mapPos.x < 0 || mapPos.x >= mapWidth || mapPos.y < 0 || mapPos.y >= mapHeight) {
                    hit =1;
                    break;
                }

                if (worldMap[mapPos.x][mapPos.y] > 0) hit = 1;
            }

            if (side == 0) perpWallDist = sideDist.x - deltaDist.x;
            else    perpWallDist = sideDist.y - deltaDist.y;

            int lineHeight = (perpWallDist > 0.0) ? int(screenHeight / perpWallDist) : screenHeight;

            int drawStart = -lineHeight / 2 + screenHeight / 2;
            if (drawStart < 0) drawStart = 0;
            int drawEnd = lineHeight / 2 + screenHeight / 2;
            if(drawEnd >= screenHeight) drawEnd = screenHeight - 1;

            sf::Color col = sf::Color::Yellow;
            switch (worldMap[mapPos.x][mapPos.y]) {
                case 1: col = sf::Color::Red; break;
                case 2: col = sf::Color::Green; break;
                case 3: col = sf::Color::Blue; break;
                case 4: col = sf::Color::White; break;
                case 5: col = sf::Color(255, 128, 0); break;
                default: break;
            }

            if (side == 1) col = sf::Color(col.r / 2, col.g / 2, col.b/2);

            sf::RectangleShape column(sf::Vector2(1.f, float(drawEnd - drawStart +1)));
            column.setPosition(float(x), float(drawStart));
            column.setFillColor(col);
            window.draw(column);        
    }
}
